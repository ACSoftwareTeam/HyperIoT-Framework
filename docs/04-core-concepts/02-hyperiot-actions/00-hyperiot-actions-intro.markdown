# Actions: HuperIoTAction [](id=hyperiot-actions)

The HyperIoTAction interface contained within the HyperIoTBase-api module defines the concept of an <b>action</b>.

An action abstractly represents an operation to be performed on a resource or entity.
Examples of actions are the so-called CRUD actions for entities, i.e., the find, find all, save, update, and remove actions, or the view permission on a page, etc.

Among the methods defined by the <i>HyperIoTAction</i> interface is the <i>getResourceName()</i> method that allows the action to be associated with a resource, the <i>getActionName()</i> method that allows an action to be defined by assigning a name to it, and the <i>getActionId()</i> method that returns an integer power of 2 and will be used by the permission system to check whether a user, through his or her role, has permission to perform the action on the associated resource.

The <b>HyperIoTBase-action</b> module, as the name suggests, provides the classes and interfaces to work smoothly and effectively with actions.
Very important is the abstract <i>HyperIoTPermissionActivator</i> class that allows actions to be registered in the OSGi context. Specifically, the actions that will be registered will be defined by implementing the abstract method <i>getActions()</i>.

Custom modules of type action, such as those generated by the ```yo hyperiot:new-actions-module``` command, extend the <i>HyperIoTPermissionActivator</i> class and implement the getActions() method so that CRUD Actions are registered by default:

```
@Override
public HyperIoTActionList getActions() {
    // creates base Actions save,update,remove,find,findAll for the specified entity
    ArrayList<HyperIoTActionList> actionsLists = new ArrayList<>();
    log.info("Registering base CRUD actions...");
    HyperIoTActionList actionList = HyperIoTActionFactory.createBaseCrudActionList(CustomEntityAction.class.getName(),
            CustomEntityAction.class.getName());
            
    //TO DO: add more actions to actionList here...
    
    actionList.addAction(HyperIoTActionFactory.createAction(
    CustomEntity.class.getName(), CustomEntity.class.getName(), CustomEntityAction.CUSTOM_ACTION));
    actionsLists.add(actionList);
    return actionsLists;
}
```

Of course, the method implementation can be modified so that any custom actions we create can also be registered for different entities.

In addition to the abstract HyperIoTPermissionActivator class, the HyperIoTActionName interface is also implemented, which allows the name of an action to be defined in a simple way. It is implemented via an enumeration that implements the unique abstract method getName():

```
public enum CustomEntityAction implements HyperIoTActionName {
   
   //TO DO: add enumerations here
   CUSTOM_ACTION("custom_action");

   private String name;

   private CustomEntityAction(String name) {
      this.name = name;
   }

   public String getName() {
      return name;
   }

}
```

HyperIoT Framework, again through the HyperIoTBase-actions module, provides other utility classes, including the HyperIoTActionFactory class that makes factory methods available to instantiate actions and the HyperIoTActionUtils class that allows you to retrieve actions registered in the OSGi context.

NB: The HyperIoTBase-actions module makes available only what is needed for defining actions and nothing else. The functionality needed to verify permissions for actions on resources is contained in the HyperIoTBase-security module.

Finally, you can view all actions registered in the OSGi context by invoking the REST service http://localhost:8182/hyperiot/permissions/actions in GET.